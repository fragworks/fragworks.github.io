<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Documentations on FRAG</title>
    <link>http://fragworks.io/documentation/</link>
    <description>Recent content in Documentations on FRAG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://fragworks.io/documentation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dependencies</title>
      <link>http://fragworks.io/documentation/dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://fragworks.io/documentation/dependencies/</guid>
      <description>Start  Dependencies  Customize        Nim
devel version
    Nim is a systems and applications programming language. Statically typed and compiled, it provides unparalleled performance in an elegant package.  High-performance garbage-collected language Compiles to C, C++ or JavaScript Produces dependency-free binaries Runs on Windows, macOS, Linux, and more   Windows, OSX, Linux  Nim Compilation Instructions  Compiling The Nim compiler currently officially supports the following platform and architecture combinations:  Windows (Windows XP or greater) - x86 and x86_64 Linux (most, if not all, distributions) - x86, x86_64, ppc64 and armv6l Mac OS X (10.</description>
    </item>
    
    <item>
      <title>Documentation</title>
      <link>http://fragworks.io/documentation/index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://fragworks.io/documentation/index/</guid>
      <description>Start  Dependencies  Customize     2 ways to get started  1
 Use Nimble (recommended): nimble install frag   2
 Clone the repository and install from source (advanced): git clone git@github.com:fragworks/frag.git &amp;amp;&amp;amp; cd frag nimble install -y</description>
    </item>
    
    <item>
      <title>Install</title>
      <link>http://fragworks.io/documentation/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://fragworks.io/documentation/install/</guid>
      <description>Start  Dependencies  Customize     2 ways to get started  1
 Use Nimble (recommended): nimble install frag   2
 Clone the repository and install from source (advanced): git clone git@github.com:fragworks/frag.git &amp;amp;&amp;amp; cd frag nimble install -y</description>
    </item>
    
    <item>
      <title>Configure</title>
      <link>http://fragworks.io/documentation/config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://fragworks.io/documentation/config/</guid>
      <description>Options  API Docs     Configuration Options  Common settings which control application behavior   Every application built with FRAG, is expected to provide a minimal set of configuration options when initializing the framework.  A Configuration object should be instantiated, and filled out with values which make sense for your application. Config( rootWindowTitle: &amp;ldquo;Your Application Name&amp;rdquo;, rootWindowPosX: window.posUndefined, rootWindowPosY: window.posUndefined, rootWindowWidth: 800, rootWindowHeight: 600, resetFlags: ResetFlag.</description>
    </item>
    
    <item>
      <title>Game Loop</title>
      <link>http://fragworks.io/documentation/example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://fragworks.io/documentation/example/</guid>
      <description>Concept  Implementation  Example     Example  Minimal FRAG application implementing game loop  #Nim STD Library Imports import events #Dependency Imports import bgfxdotnim, sdl2 as sdl #Frag Imports import frag, frag/config, frag/graphics/window, frag/logger, frag/modules/graphics
type App = ref object
proc resize*(e: EventArgs) = let event = SDLEventMessage(e).event let sdlEventData = event.sdlEventData let graphics = event.graphics graphics.setViewRect(0, 0, 0, uint16 sdlEventData.window.data1, uint16 sdlEventData.window.data2)
proc initApp(app: App, ctx: Frag) = logDebug &amp;ldquo;Initializing app&amp;hellip;&amp;rdquo; ctx.</description>
    </item>
    
    <item>
      <title>Game Loop</title>
      <link>http://fragworks.io/documentation/gameloop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://fragworks.io/documentation/gameloop/</guid>
      <description>Concept  Implementation  Example     The Concept  Initialize. Update. Render. Shutdown.  Almost every game is constructed around a game loop, which serves a number of purposes.
Generally, a game loop is initiated and will run continuously until gameplay terminates. During each iteration of the game loop, a number of tasks are carried out. Tasks which are commonly executed during a single loop iteration include:</description>
    </item>
    
    <item>
      <title>Game Loop</title>
      <link>http://fragworks.io/documentation/implementation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://fragworks.io/documentation/implementation/</guid>
      <description>Concept  Implementation  Example     The Implementation  How FRAG does it  FRAG&amp;rsquo;s game loop is pretty standard and can be broken down into several sections.
Initialization  Let&amp;rsquo;s get things started&amp;hellip; The initialization phase of the game loop begins when the startFrag procedure is called.
Engine Code proc startFrag*T = var ctx = Frag() ctx.init(config, app) app.initApp(ctx)  Example Game Code proc initApp(app: App, ctx: Frag) = # Application initialization logic goes here!</description>
    </item>
    
  </channel>
</rss>